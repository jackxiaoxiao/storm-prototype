### 需要建立索引的场景
+ 直接条件查询的字段 where
+ 查询中与其它表关联的字段
+ 查询中排序的字段
+ 查询中统计或分组统计的字段

###  什么情况下应不建或少建索引
* 表记录太少
如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，这种情况下ORACLE至少要往返读取数据块两次。而不用索引的情况下ORACLE会将所有的数据一次读出，处理速度显然会比用索引快。
如表zl_sybm（使用部门）一般只有几条记录，除了主关键字外对任何一个字段建索引都不会产生性能优化，实际上如果对这个表进行了统计分析后ORACLE也不会用你建的索引，而是自动执行全表访问。如：
select * from zl_sybm where sydw_bh=’5401’（对sydw_bh建立索引不会产生性能优化）
* 经常插入、删除、修改的表.
* 数据重复且分布平均的表字段.假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。
* 经常和主字段一块查询但主字段索引值比较多的表字段

### mysql在建立索引优化时需要注意的问题
+ 比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;
  如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效
  率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,
  salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀
  特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
+ 使用短索引. 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
+ 排序的索引问题.mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。